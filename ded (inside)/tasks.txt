1. квадраточька
типа формулировка это написать прогу, решающую квадратное уравнение) но суть раскрывается далее
1) точность. неправильно сравнивать даблы и флоаты оператором ==. у них есть погрешность. мы считаем два числа равными, если они находятся в пределах погрешности (пусть это условно 1e-7). 
почему это важно? если вдруг ноль стал 1e-20,  то мы поделим на него, и получится огромное число, которое может стать NaN (not a number). тогда прога сломается. 

Пример вычислений, от которых появится «погрешность»:

double a = 1е+10;
a += 1е-10;
a -= 1е+10;
a -= 1e-10; 

чему будет равно a?

2) корректность ввода. нужно проверять, что юзер ввел то, что нужно. если он решил ввести числа буквами ("один два один"), то программа либо должна это правильно проинтерпретировать (но этого делать не нужно), либо вежливо писать "прошу прощения, ты что-то тут непонятное написал, введи-ка еще раз."  проще всего это сделать с помощью возвращаемого значения scanf (погуглите, что он возвращает).  либо посимвольным считыванием всего, и дальнейшим посимвольным анализом, но это уже факультативно (такой подход более безопасный).


3) Пишите комментарии в doxygen стиле. И желательно соберите файлик с документацией. В базовом варианте это займёт 15 минут гугления и 15 минут написания комментариев. 

4) (пока факультативно) пусть есть уравнение 1e-8*x^2 + 2*1e-8*x + 1e-8 = 0. оно имеет единственное решение -1. но при выполнении пункта 1) оно будет проинтерпретировано, как 0*x^2 + 0*x + 0 = 0 и будет иметь бесконечное число решений. хорошо, если ваша прога выдаст в таком случае ответ -1.

5) (факультативно) поверх обязательных юниттестов можно поверх них опционально добавить считывание данных для теста из файла. 

новые пункты, чтобы обратить внимание:

1) если человек вводит четыре числа, то программа часто интерпретирует только первые три. то есть если я введу 1 2 1 2, то прога будет решать уравнение 1 2 1. надо чтобы она ругалась на лишний коэфициент. иначе пользователь может решить, что вы решаете уравнение 3 степени, да ещё и неправильно. 

слова про то, что пользователь сам должен понимать, что это квадратка не принимаются. когда вы неправильно вводите данные на нормальный сайт, он вам об этом пишет, а не интерпретирует их неявным образом.

2) проверяйте, чтобы ваш код мог запускаться на другом компе. поэтому если есть ваши библиртеки, то их тоже надо положить на гитхаб. и никаких абсолютных путей типа C://Dimasik//my_proga//ILab, на других компах этого очевдино нет

2. функции
Свои версии функций из стандартной библиотеки:
int puts(const char *s);
const char *strchr(const char *s, int c);
size_t strlen(const char *str);
char *strcpy(char *s, const char *t);
char *strncpy(char *dest, const char *source, size_t n);
int strcmp(const char *str1, const char *str2);
char *strcat(char *str1, const char *str2);
char *fgets(char *s, int n, FILE *stream);
char *strdup(const char *s);
ssize_t getline (char **lineptr, size_t *n, FILE *stream);

ко всему требования были чтоб четко по кернигану ричи (так какое-то приложениие, не помню уже)
getline там нету но суть такова

https://linuxhint.com/getline-function-c/

3. онегин
Есть два файла: гигатекст и пустой. В пустой файл кладем гигатекст, где строки отсортированы лексикографически (типо как слова в алфавинтом порядке сортируют); текст, отсортированный так же, но с конца строки; исходный текст
В сортировке мы не учитываем не-буквы в начале и конце строки, в отсортированных их быть не должно, в исходном они должны быть
Надо взять и заюзать структуры для хранения каждой строки и (по-хорошему) текста. Не надо хранить текст как массив строк (еще уебищнее если это строки выделенной длины), нужно ебнуть calloc под число прочитанных символов (разрешено  достать размер файла из fstat затем заюзать realloc) и ебнуть массив структур из указателя на начало каждой строки и её длины. Ну и сортируем структуры

4. Стек
Структура, где главное - массивчьик с командами StackPush и StackPop, а также хуева туча методов для экономии памяти, создания стека, защиты стека (если еблан на выполняющем таску вылезет за массив), логирования
Что надо запилить - канареечная защита стека и (по-хорошему) данных, хеш-защита стека и данных, обработчик ошибок, метод для создания логов, 
